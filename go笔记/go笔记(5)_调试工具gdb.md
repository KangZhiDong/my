2年前刚开始看go的时候，一直不明白go是怎么进行debug的，总以为ide里面如同c或者java一样，自带了debug工具，可以设断点查当前变量值什么的。
实际上大概是想多了，并没有完善到这种程度。

现在的话，代码写多了，如果没有合适的debug工具，始终是受到一定的制约。好在在官网介绍了一个叫gdb的工具。

那么我就按他的步骤来看一下这个gdb到底是什么样的用法吧。

首先，要安装gdb，这个就自行解决了。

接着，就要
`Pass the '-w' flag to the linker to omit the debug information`
从字面的意思看是，是用-w这个参数来达到移除debug信息的目的（估计是go自带的debug信息吧）不管了，官方让我怎么做，我就怎么做。
`go build -ldflags "-w" main.go`

main.go是我手写的一个函数
```go
package main
import "fmt"

func main()  {
	var val int8 = 1
	fmt.Println(val)
}
```
接下来，还要关闭gc compiler时产生的内联函数的调用和登记变量
`The code generated by the gc compiler includes inlining of function invocations and registerization of variables. `
其实我也看不懂具体什么意思，不过官方既然让你关，你就关。
`go build -gcflags "-N -l" main.go`

接着，官方又推荐我们设置`GOTRACEBACK=crash`来生成core文件来查看程序崩溃时的堆栈信息
除了crash以外，还有其它的几种方式
```
GOTRACEBACK=none omits the goroutine stack traces entirely. 
GOTRACEBACK=single (the default) behaves as described above. 
GOTRACEBACK=all adds stack traces for all user-created goroutines. 
GOTRACEBACK=system is like “all” but adds stack frames for run-time functions and shows goroutines created internally by the run-time. 
GOTRACEBACK=crash is like “system” but crashes in an operating system-specific manner instead of exiting. For example, on Unix systems, the crash raises SIGABRT to trigger a core dump.
```
这里不多做描述，心里有个概念即可。
